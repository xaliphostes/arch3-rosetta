#pragma once
#include "CodeWriter.h"

// ============================================================================
// Embind C++ Code Generator
// ============================================================================
class EmbindGenerator : public CodeWriter {
  public:
    using CodeWriter::CodeWriter;

    void generate() override {
        write_header();
        write_includes();
        write_helpers();
        write_bindings();
    }

  private:
    void write_header() {
        line("// "
             "================================================================="
             "===========");
        line("// AUTO-GENERATED EMSCRIPTEN BINDINGS - DO NOT EDIT");
        line("// Generated by binding_generator from Rosetta introspection");
        line("// "
             "================================================================="
             "===========");
        line();
    }

    void write_includes() {
        line("#include <emscripten/bind.h>");
        line("#include <emscripten/val.h>");
        line();
        line("#include <rosetta/rosetta.h>");
        line();
        line("// Arch headers");
        for (const auto &header : config_.arch_headers) {
            line("#include <" + header + ">");
        }
        line();
        line("#include \"registration.h\"");
        line();
        line("using namespace emscripten;");
        line();
    }

    void write_helpers() {
        line("// "
             "================================================================="
             "===========");
        line("// JavaScript TypedArray <-> C++ conversion helpers");
        line("// "
             "================================================================="
             "===========");
        line();

        line("arch::Vector3 jsArrayToVector3(const val& arr) {");
        indent();
        line("return arch::Vector3(arr[0].as<double>(), arr[1].as<double>(), "
             "arr[2].as<double>());");
        dedent();
        line("}");
        line();

        line("val vector3ToJsArray(const arch::Vector3& v) {");
        indent();
        line("val arr = val::global(\"Float64Array\").new_(3);");
        line("arr.set(0, v[0]); arr.set(1, v[1]); arr.set(2, v[2]);");
        line("return arr;");
        dedent();
        line("}");
        line();

        line("val matrix33ToJsArray(const arch::Matrix33& m) {");
        indent();
        line("val arr = val::global(\"Float64Array\").new_(9);");
        line("arr.set(0, m.get(0,0)); arr.set(1, m.get(0,1)); arr.set(2, "
             "m.get(0,2));");
        line("arr.set(3, m.get(0,1)); arr.set(4, m.get(1,1)); arr.set(5, "
             "m.get(1,2));");
        line("arr.set(6, m.get(0,2)); arr.set(7, m.get(1,2)); arr.set(8, "
             "m.get(2,2));");
        line("return arr;");
        dedent();
        line("}");
        line();

        line("std::vector<double> jsArrayToVector(const val& arr) {");
        indent();
        line("const size_t len = arr[\"length\"].as<size_t>();");
        line("std::vector<double> vec(len);");
        line("for (size_t i = 0; i < len; ++i) vec[i] = arr[i].as<double>();");
        line("return vec;");
        dedent();
        line("}");
        line();

        line("val vectorToJsArray(const std::vector<double>& vec) {");
        indent();
        line("val arr = val::global(\"Float64Array\").new_(vec.size());");
        line("for (size_t i = 0; i < vec.size(); ++i) arr.set(i, vec[i]);");
        line("return arr;");
        dedent();
        line("}");
        line();
    }

    void write_bindings() {
        line("// "
             "================================================================="
             "===========");
        line("// Embind Module Definition");
        line("// "
             "================================================================="
             "===========");
        line();
        line("EMSCRIPTEN_BINDINGS(" + config_.module_name + "_module) {");
        indent();
        line();
        line("arch_rosetta::register_arch3_classes();");
        line();

        auto &registry = rosetta::Registry::instance();
        arch_rosetta::register_arch3_classes();

        for (const auto &name : registry.list_classes()) {
            auto *h = registry.get_by_name(name);
            if (h)
                write_class_binding(name, h);
        }

        write_utility_functions();

        dedent();
        line("}");
    }

    void write_class_binding(const std::string &name,
                             rosetta::ClassMetaHolder *h) {
        line("// --- " + name + " ---");
        std::string cpp_type = h->get_cpp_type_name();
        auto base = h->get_base_class();

        if (!base.empty()) {
            line("class_<" + cpp_type + ", base<" + base + ">>(\"" + name +
                 "\")");
        } else {
            line("class_<" + cpp_type + ">(\"" + name + "\")");
        }
        indent();
        line(".smart_ptr<std::shared_ptr<" + cpp_type + ">>(\"" + name +
             "Ptr\")");

        for (const auto &ctor : h->get_constructors()) {
            auto params = ctor.get_param_types();
            if (params.empty()) {
                line(".constructor<>()");
            } else {
                std::string p;
                for (size_t i = 0; i < params.size(); ++i) {
                    if (i > 0)
                        p += ", ";
                    p += params[i];
                }
                line(".constructor<" + p + ">()");
            }
        }

        for (const auto &m : h->get_methods()) {
            line(".function(\"" + m + "\", &" + cpp_type + "::" + m + ")");
        }

        line(";");
        dedent();
        line();
    }

    void write_utility_functions() {
        line("// Utility functions");
        line("function(\"listClasses\", &[]() { return "
             "rosetta::Registry::instance().list_classes(); });");
        line("function(\"getClassMethods\", &[](const std::string& n) {");
        indent();
        line("auto* h = rosetta::Registry::instance().get_by_name(n);");
        line("if (!h) throw std::runtime_error(\"Class not found: \" + n);");
        line("return h->get_methods();");
        dedent();
        line("});");
    }
};
