// ============================================================================
// arch3 Library Rosetta Registration
// ============================================================================
// Generated by rosetta-create
//
// This file registers arch3 classes with Rosetta for introspection.
//
// IMPORTANT: For overloaded functions, use FULLY QUALIFIED type names
// because the macro stringifies the type and it must be valid C++ in the
// generated binding file.
// ============================================================================
#pragma once

#include <rosetta/rosetta.h>

// TODO: Add your library headers here
#include <Arch/core/Inequality.h>
#include <Arch/core/Material.h>
#include <Arch/core/Model.h>
#include <Arch/core/Remote.h>
#include <Arch/core/Surface.h>
#include <Arch/postprocess/Postprocess.h>
#include <Arch/solvers/Seidel.h>
#include <functional>


namespace arch3_rosetta {

inline void register_all() {
    ROSETTA_REGISTER_CLASS(arch::Matrix33)
        .constructor<>()
        .constructor<double, double, double, double, double, double>()
        .lambda_method<double>(
            "xx", [](const arch::Matrix33 &m) { return m.get(0, 0); })
        .lambda_method<double>(
            "xy", [](const arch::Matrix33 &m) { return m.get(0, 1); })
        .lambda_method<double>(
            "xz", [](const arch::Matrix33 &m) { return m.get(0, 2); })
        .lambda_method<double>(
            "yy", [](const arch::Matrix33 &m) { return m.get(1, 1); })
        .lambda_method<double>(
            "yz", [](const arch::Matrix33 &m) { return m.get(1, 2); })
        .lambda_method<double>(
            "zz", [](const arch::Matrix33 &m) { return m.get(2, 2); })
        .lambda_method<std::string>("__repr__", [](const arch::Matrix33 &m) {
            return "xx=" + std::to_string(m.get(0, 0)) +
                   ", xy=" + std::to_string(m.get(0, 1)) +
                   ", xz=" + std::to_string(m.get(0, 2)) +
                   ", yy=" + std::to_string(m.get(1, 1)) +
                   ", yz=" + std::to_string(m.get(1, 2)) +
                   ", zz=" + std::to_string(m.get(2, 2));
        });

    // Bind Vector3 if needed
    ROSETTA_REGISTER_CLASS(arch::Vector3)
        .constructor<>()
        .constructor<double, double, double>()
        .lambda_method<double>("x", [](const arch::Vector3 &v) { return v[0]; })
        .lambda_method<double>("y", [](const arch::Vector3 &v) { return v[1]; })
        .lambda_method<double>("z", [](const arch::Vector3 &v) { return v[2]; })
        .lambda_method<std::string>("__repr__", [](const arch::Vector3 &v) {
            return "x=" + std::to_string(v[0]) + ", y=" + std::to_string(v[1]) +
                   ", z=" + std::to_string(v[2]);
        });

    ROSETTA_REGISTER_CLASS(arch::Model)
        .constructor<>()
        .method("setHalfSpace", &arch::Model::setHalfSpace)
        .method("setMaterial", &arch::Model::setMaterial)
        .method("addRemote", &arch::Model::addRemote)
        .method("nbDof", &arch::Model::nbDof);

    ROSETTA_REGISTER_CLASS(arch::Surface)
        .constructor<arch::Model *, const std::vector<double> &,
                     const std::vector<int> &>()
        .overloaded_method("setBcType",
                           ROSETTA_OVERLOAD(arch::Surface, void, setBcType,
                                            const String &, const String &))
        // .method("addTic", arch::Surface::addTic)
        // .method("addDic", arch::Surface::addDic)
        .method("setBcValues", &arch::Surface::setBcValues);

    // TODO
    // ROSETTA_REGISTER_CLASS(arch::Coulomb).constructor<>();
    // ROSETTA_REGISTER_CLASS(arch::CoulombOrtho).constructor<>();

    ROSETTA_REGISTER_CLASS(arch::Material)
        .constructor<double, double, double>()
        .method("poisson", &arch::Material::poisson)
        .method("young", &arch::Material::young)
        .method("density", &arch::Material::density)
        .method("shear", &arch::Material::shear)
        .method("lame", &arch::Material::lame)
        .method("thermalExpansion", &arch::Material::thermalExpansion)
        .method("setPoisson", &arch::Material::setPoisson)
        .method("setYoung", &arch::Material::setYoung)
        .method("setDensity", &arch::Material::setDensity)
        .method("setThermalExpansion", &arch::Material::setThermalExpansion);

    ROSETTA_REGISTER_CLASS(arch::BaseRemote);

    ROSETTA_REGISTER_CLASS(arch::RemoteStress)
        .inherits_from<arch::BaseRemote>("BaseRemote")
        .constructor<>()
        .method("seth", &arch::RemoteStress::seth)
        .method("setH", &arch::RemoteStress::setH)
        .method("setv", &arch::RemoteStress::setv)
        .method("setTheta", &arch::RemoteStress::setTheta);

    ROSETTA_REGISTER_CLASS(arch::UserRemote)
        .inherits_from<arch::BaseRemote>("BaseRemote")
        .constructor<std::function<arch::Matrix33(double, double, double)>>();

    ROSETTA_REGISTER_CLASS(arch::IterativeSolver)
        .method("run", &arch::IterativeSolver::run);

    ROSETTA_REGISTER_CLASS_AS(arch::SeidelSolver, "SeidelSolver")
        .inherits_from<arch::IterativeSolver>("IterativeSolver")
        .constructor<arch::Model &>()
        .lambda_method<bool>(
            "run", [](arch::SeidelSolver &self) { return self.run(); });

    ROSETTA_REGISTER_CLASS_AS(arch::Postprocess, "Postprocess")
        .constructor<arch::Model &>()
        .method("displ", &arch::Postprocess::displ)
        .method("strain", &arch::Postprocess::strain)
        .method("stress", &arch::Postprocess::stress)
        .method("displAt", &arch::Postprocess::displAt)
        .method("strainAt", &arch::Postprocess::strainAt)
        .method("stressAt", &arch::Postprocess::stressAt)
        .method("burgers", &arch::Postprocess::burgers)
        .method("burgersPlus", &arch::Postprocess::burgersPlus)
        .method("burgersMinus", &arch::Postprocess::burgersMinus)
        .method("residualTractions", &arch::Postprocess::residualTractions);
}

} // namespace arch3_rosetta
